from elements import *
import json


class AstToElementParser:
    """
    This parser takes in an AST generated by parsing Markdown with mistune,
    and converts it to AST consisting of Element classes.
    """

    def __init__(self) -> None:
        pass

    def __str__(self) -> str:
        return f"<section>{ ''.join(map(str, self._elements)) }\n</section>\n\n"

    def parse_start(self, node):
        stats = {"level": 0, "rule": None}
        rules = ["section"]
        e = ElementGroup(None)
        e.group_tag = "body"
        elements = [e]
        return self.parse(node, rules, stats, elements)

    def parse(self, nodes, rules, stats, elements):
        """
        Parse the nodes
        """
        stats = stats.copy()

        i = 0

        while i < len(nodes):
            node = nodes[i]
            rule = rules[0]
            if rule == "section":
                rules.insert(0, "elements")
                e = ElementGroup(None)
                e.group_tag = "section"
                elements.append(e)
                continue
            elif rule == "elements" or rule[0] == "h":
                if node["type"] == "heading":
                    lvl = node["level"]
                    while elements[-1].group_tag[0] == "h" and lvl <= int(
                        elements[-1].group_tag[1]
                    ):
                        e = elements.pop()
                        elements[-1].add_element(e)
                    while rule[0] == "h" and lvl < int(rule[1]):
                        rule = rules.pop(0)
                    e = ElementGroup(None)
                    e.group_tag = f"h{lvl}"
                    header_text = node["children"][0]["text"]
                    e.group_class = header_text
                    elements.append(e)
                    rules.insert(0, f"h{lvl}")
                    i += 1
                    continue
                elif node["type"] == "text":
                    texts = node["text"].split("\n")
                    for t in texts:
                        if t[:2] == "(h" and t[3] == ")":
                            e = ElementHeader(
                                None,
                                text=t[5:],
                                level=int(t[2]),
                                font_size=6 - int(t[2]),
                            )
                        elif len(t) > 0 and t != "\n":
                            e = ElementParagraph(None, t)
                        else:
                            continue
                        elements[-1].add_element(e)
                    i += 1
                    continue
                elif node["type"] == "image":
                    e = ElementImage(None, node["src"])
                    if "alt" in node and len(node["alt"]) > 0 and node["alt"][0] == "{":
                        e.set_context(json.loads(node["alt"]))
                    elements[-1].add_element(e)
                    i += 1
                elif node["type"] == "link":
                    e = ElementLink(None)
                    e.text = node["children"][0]["text"]
                    e.href = node["link"]
                    elements[-1].add_element(e)
                    i += 1
                elif node["type"] == "list":
                    if node["ordered"]:
                        ele = ElementList(None)
                    else:
                        ele = ElementGroup(None)
                        ele.group_tag = "div"
                    for c in node["children"]:
                        n = c["children"]
                        stats["level"] += 1
                        el = self.parse(n, ["elements"], stats, [ElementGroup(None)])
                        stats["level"] -= 1
                        ele.add_element(el)
                    elements[-1].add_element(ele)

                    i += 1
                elif node["type"] in ["block_text", "paragraph"]:
                    stats["level"] += 1
                    e = ElementGroup(None)
                    e.group_tag = "p"
                    e = self.parse(node["children"], ["elements"], stats, [e])
                    stats["level"] -= 1
                    elements[-1].add_element(e)
                    i += 1
                elif node["type"] == "thematic_break":
                    while elements[-1].group_tag != "body":
                        e = elements.pop()
                        elements[-1].add_element(e)
                    while rules[0] != "section":
                        rules.pop(0)
                    i += 1
                    continue

        while not elements[-1].group_tag in ["section", "body"] and len(elements) > 1:
            e = elements.pop()
            elements[-1].add_element(e)

        if len(elements) == 1:
            e = elements[0]
            if e.get_general_type() == "group" and len(e.elements) == 1:
                e = e.elements[0]
            return e
        else:
            if stats["level"] > 0:
                e = ElementGroup(None)
                e.group_tag = "div"
                e.add_elements(elements)
                return e
            elif elements[-1].group_tag == "section":
                e = elements.pop()
                elements[-1].add_element(e)
                return elements[-1]
            return e
